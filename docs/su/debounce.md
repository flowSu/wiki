# 函数防抖与函数节流

::: tip Tips
有关函数防抖与函数节流，在我们日常开发中经常遇到，趁着假期在家暂时无事，好好的整理一番，以期能够掌握常见的函数防抖和函数节流的应用场景，提升用户体验。
:::

## 问题引入

**问题1：** 如果想要实现dom的拖拽功能（在app生成器后台管理中有许多类似的功能），假定我们已经正常的实现了业务需求，但是只要元素稍微拖拽一点，浏览器会因为大量的回调而造成假死，我们只能等待回调结束。

![问题1](https://picwms.newbanker.cn/pl1xc6iimpp9heyd8xksbsfk98zr2mxc@@@drag.png@@@png@@@23310)

**问题2：** 在日常的开发时，点击按钮提交form表单的事件，我们在测试时快速点击几次，会看到network中发了好几次网络请求，那么，如何避免这种情况呢？

> 为了避免出现上述的两种情况，便出现了**函数防抖**和**函数节流**这2种概念。其实，说白了就是在一定时间内控制想让其执行的函数（或方法）的次数

## 函数防抖(debounce)

**概念** 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新开始计时。

**生活中的实例** 我们平常上班的宝能中心的电梯，当门将要关闭时，这时按下开门键，门又要重新计时，直到达到关门时间，在未达到关门时间时如果有人又重新按了关闭按钮，则有要重新计时

## 函数节流(throttle)

**概念** 规定一个单位时间内，在这个单位时间内，只能有一次触发事件的函数回调执行，如果在同一个时间内某个事件被触发多次，只有一次生效。

**生活中的实例** 浏览器模糊搜索只能提醒时，会在input上绑定keyup事件，但是此时我们肯定不想频繁的触发keyup事件，此时就用到了函数节流，即在一段时间间隔内只执行一次

## 实例分析

我们现在假设，观察的总时间为10秒，暂且规定1秒为最小的时间观察单位

**如果时间的触发频率为0.5秒/次，那么**

函数防抖示意图如图所示：

![函数防抖](https://gitee.com/vueman/md_pic/raw/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-16%20%E4%B8%8B%E5%8D%887.54.01.png)

因为此时事件无法等到1秒就再次被触发，所以在总的观察时间内，事件只有一次被成功执行

函数节流示意图如图所示：

![函数节流](https://gitee.com/vueman/md_pic/raw/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-16%20%E4%B8%8B%E5%8D%887.50.45.png)

因为事件的执行频率是0.5秒/次，但最小的时间间隔为1秒/次，所以在1秒内，总有一次事件回调被忽略，所以1秒内只有1次成功执行

**如果触发事件的频率改为2秒/次，那么**

函数防抖示意图如图所示：

![函数防抖2](https://gitee.com/vueman/md_pic/raw/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-16%20%E4%B8%8B%E5%8D%888.00.29.png)

因为2秒/次已经大于了规定的最小时间，所以每计时两秒便触发一次。

函数节流示意图如图所示：

![函数节流2](https://gitee.com/vueman/md_pic/raw/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-16%20%E4%B8%8B%E5%8D%887.58.04.png)

同样，2秒/次 大于了最小时间规定，所以每一次触发都生效。

## 应用场景

对于函数防抖，有如下几种典型应用场景：

* 表单提交按钮增加函数防抖阻止多次提交
* 对于input输入框连续输入进行ajax校验时，能有效减少请求次数
* 屏幕滚动事件、屏幕resize事件

> 总的来说，函数防抖适用于多次事件提交一次响应的情况

对于函数节流，最典型的应用莫过于以下几种：

* 游戏中的刷新频率
* DOM元素拖拽
* canvas画笔功能

> 总的来说，函数节流适用于大量事件按时间平均分配触发

## 源码解析

**函数防抖源码解析**

```javascript
function debounce(fn, wait) {
  var timer = null
  return function () {
      var context = this
      var args = arguments
      if (timer) {
          clearTimeout(timer)
          timer = null
      }
      timer = setTimeout(function () {
          fn.apply(context, args)
      }, wait)
  }
}

var fn = function () {
  console.log('boom')
}

setInterval(debounce(fn,500),1000) // 第一次在1500ms后触发，之后每1000ms触发一次

setInterval(debounce(fn,2000),1000) // 不会触发一次（我把函数防抖看出技能读条，如果读条没完成就用技能，便会失败而且重新读条）
```
之所以返回一个函数，因为防抖本身更像是一个函数修饰，所以就做了一次函数柯里化。里面也用到了闭包，闭包的变量是timer。

**函数节流源码解析**

```javascript
function throttle(fn, gapTime) {
  let _lastTime = null

  return function () {
    let _nowTime = + new Date()
    if (_nowTime - _lastTime > gapTime || !_lastTime) {
      fn()
      _lastTime = _nowTime
    }
  }
}

let fn = ()=>{
  console.log('boom')
}

setInterval(throttle(fn,1000),10)
```
## 写在最后

函数防抖和函数节流在我们日常的开发过程中应用极其广泛，说白了，**函数防抖和函数节流是在时间轴上控制函数的执行次数**。防抖可以类比为电梯不断上乘客,节流可以看做幻灯片限制频率播放电影。

在我们日常的开发工作中，并不需要我们每次都去实现函数防抖或者函数节流，目前应用最广泛的就是[lodash](http://www.css88.com/doc/lodash/)

lodash的用法纷繁复杂，以下是在日常开发中使用比较高频的一些用法举例，[详情点击](https://www.jianshu.com/p/d46abfa4ddc9)
